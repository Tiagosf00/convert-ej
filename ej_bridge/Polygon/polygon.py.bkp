#  -*- coding: utf-8 -*-

# from . import problem

from base64 import b64encode
import os
import shutil
import xml.etree.ElementTree as ET
from zipfile import ZipFile

import sys
sys.path.append('..')
import problem


def _get_content(file, mode='r'):
    with open(file, mode) as f:
        return f.read()


def _get_limits(root):
    testset = root.find('judging/testset')
    time_msec = int(testset.find('time-limit').text)
    memory_B = int(testset.find('memory-limit').text)

    return {'time_sec': time_msec // 1000,
            'memory_MB': memory_B // (2 ** 20)}


def _get_tests(root, package_dir):
    test_files = [entry.path
                  for entry in os.scandir(os.path.join(package_dir, 'tests'))
                  if not entry.name.endswith('a')]
    test_samples = ['sample' in e.attrib
                    for e in root.findall('judging/testset/tests/test')]

    # Tests are listed in the XML in the same order as the files are numbered.
    tests = {'examples': {}, 'hidden': {}}
    for path, is_sample in zip(sorted(test_files), test_samples):
        test = 'examples' if is_sample else 'hidden'
        file = os.path.split(path)[-1]
        tests[test][file] = {'in': _get_content(path),
                             'out': _get_content(f'{path}.a')}

    return tests


def _parse_statement(package_dir, language='english'):
    path = os.path.join(package_dir, 'statement-sections', language)

    images = {}
    examples = {}
    with os.scandir(path) as it:
        for entry in it:
            if not entry.name.startswith('.') and entry.is_file():
                if entry.name.endswith(('.png', 'jpg', '.eps')):
                    image = _get_content(entry.path, 'rb')
                    images[entry.name] = str(b64encode(image), 'utf-8')
                elif entry.name.startswith('example.'):
                    ex = entry.name.split('.')[1]
                    if ex not in examples:
                        examples[ex] = {}
                    if entry.name.endswith('.a'):
                        examples[ex]['out'] = _get_content(entry.path)
                    else:
                        examples[ex]['int'] = _get_content(entry.path)

    return {'title': _get_content(os.path.join(path, 'name.tex')),
            'context': _get_content(os.path.join(path, 'legend.tex')),
            'images':  images,
            'input':  _get_content(os.path.join(path, 'input.tex')),
            'output': _get_content(os.path.join(path, 'output.tex')),
            'hints': _get_content(os.path.join(path, 'notes.tex')),
            'examples': examples}


def _unzip(package):
    # """Unzips the file into a temporary directory and returns its path."""
    file_dir, file_name = os.path.split(package)
    tmp_dir = os.path.splitext(file_name)[0]
    tmp_dir = os.path.join('/tmp', tmp_dir)

    with ZipFile(package, 'r') as f:
        f.extractall(tmp_dir)

    return tmp_dir


def _get_solutions(path, root):
    """Find the solution specified by a type parameter (language)
    and return them."""
    def to_eval_type(type):
        type = type.split('.')[0]
        if type == 'python':
            return 'py'
        return type

    def solution_code(tag):
        return {to_eval_type(e.attrib['type']): _get_content(os.path.join(path,
                                                             e.attrib['path']))
                for e in root.findall(
                    f'assets/solutions/solution[@tag="{tag}"]/source')}

    return {'main': solution_code('main'),
            'accepted': solution_code('accepted')}


def read(file, args):
    """Read the file from Polygon format and returns the tuple (Statement, Evaluator).
    """
    tmp_path = _unzip(file)
    xml = os.path.join(tmp_path, 'problem.xml')
    xml_root = ET.parse(xml).getroot()

    sections = _parse_statement(tmp_path)
    sections['tags'] = [e.attrib['value']
                        for e in xml_root.findall('tags/tag')]

    test_cases = _get_tests(xml_root, tmp_path)
    limits = _get_limits(xml_root)
    solutions = _get_solutions(tmp_path, xml_root)

    shutil.rmtree(tmp_path)  # cleanup

    handle = xml_root.attrib['short-name']
    return problem.EJudgeProblem(handle,
                                 problem.Statement(sections),
                                 problem.Evaluation(test_cases, solutions, limits))


def write(a, b):
    """Read the file from CodeRunner format and returns the tuple
    (Problem, Evaluator).
    """
    raise NotImplementedError


def add_arguments(parser):
    return parser
